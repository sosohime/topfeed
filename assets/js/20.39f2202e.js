(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{163:function(t,e,_){"use strict";_.r(e);var n=_(0),o=Object(n.a)({},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("div",{staticClass:"content"},[_("h1",{attrs:{id:"编写通用代码"}},[t._v("编写通用代码")]),t._v(" "),_("p",[t._v('在进一步介绍之前，让我们花点时间来讨论编写"通用"代码时的约束条件 - 即运行在服务器和客户端的代码。由于用例和平台 API 的差异，当运行在不同环境中时，我们的代码将不会完全相同。所以这里我们将会阐述你需要理解的关键事项。')]),t._v(" "),_("h2",{attrs:{id:"服务器和浏览器的差异"}},[t._v("服务器和浏览器的差异")]),t._v(" "),_("p",[t._v("服务器和浏览器的差异主要如下：")]),t._v(" "),t._m(0),t._v(" "),_("h2",{attrs:{id:"组件生命周期钩子函数"}},[t._v("组件生命周期钩子函数")]),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),_("h2",{attrs:{id:"访问特定平台-platform-specific-api"}},[t._v("访问特定平台(Platform-Specific) API")]),t._v(" "),t._m(3),t._v(" "),_("p",[t._v("对于共享于服务器和客户端，但用于不同平台 API 的任务(task)，建议将平台特定实现包含在通用 API 中，或者使用为你执行此操作的 library。例如，"),_("a",{attrs:{href:"https://github.com/axios/axios",target:"_blank",rel:"noopener noreferrer"}},[t._v("axios"),_("OutboundLink")],1),t._v(" 是一个 HTTP 客户端，可以向服务器和客户端都暴露相同的 API。")]),t._v(" "),_("p",[t._v("对于仅浏览器可用的 API，通常方式是，1.在「纯客户端(client-only)」的生命周期钩子函数中惰性访问(lazily access)它们。")]),t._v(" "),t._m(4),t._v(" "),_("h2",{attrs:{id:"使用-code-fence-控制代码只在客户端-浏览器执行"}},[t._v("使用 Code Fence 控制代码只在客户端/浏览器执行")]),t._v(" "),_("p",[t._v("借助于 webpack 的 definePlugin，我们可以在编译期间控制代码只运行在客户端或者服务端")])])},[function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("每个用户的浏览器实例是互相独立的，这使得在不同用户的浏览器全局环境不会互相污染，每个用户的服务器却是共享的，因此全局环境存在相互污染的可能，因此要求服务器环境下的 global 是只读的，否则可能因为用户之间的环境污染导致出错，且 global 的环境下不应该存放任何与用户相关的信息。")]),this._v(" "),e("li",[this._v("服务器的是长期运行的，浏览器通常打开的时间不会太长，因此开发者编写代码时常常忽视对内存的回收，服务器随着用户的增加和时间的累计，导致泄漏的内存很快会累计导致服务器难以承受，因此编写通用代码时需要注意对内存的回收")])])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[t._v("由于没有动态更新，所有的生命周期钩子函数中，只有 "),_("code",[t._v("constructor")]),t._v("和"),_("code",[t._v("componentWillMount")]),t._v(" 和 "),_("code",[t._v("render")]),t._v(" 会在服务器端渲染(SSR)过程中被调用。这就是说任何其他生命周期钩子函数中的代码（例如 "),_("code",[t._v("componentDidMount")]),t._v(" 或 "),_("code",[t._v("componentWillUnmount")]),t._v("），只会在客户端执行。")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[t._v("此外还需要注意的是，你应该避免在"),_("code",[t._v("constructor")]),t._v("和 "),_("code",[t._v("componentWillMount")]),t._v(" 和 "),_("code",[t._v("render")]),t._v(" 生命周期时产生全局副作用的代码，例如在其中使用 "),_("code",[t._v("setInterval")]),t._v(" 设置 timer。在纯客户端(client-side only)的代码中，我们可以设置一个 timer，然后在 "),_("code",[t._v("componentWillUnmount")]),t._v(" 生命周期时将其销毁。但是，由于在 SSR 期间并不会调用销毁钩子函数，所以 timer 将永远保留下来。为了避免这种情况，请将副作用代码移动到 "),_("code",[t._v("componentDidMount")]),t._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("通用代码不可接受特定平台的 API，因此如果你的代码中，直接使用了像 "),e("code",[this._v("window")]),this._v(" 或 "),e("code",[this._v("document")]),this._v("，这种仅浏览器可用的全局变量，则会在 Node.js 中执行时抛出错误，反之也是如此。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("请注意，考虑到如果第三方 library 不是以上面的通用用法编写，则将其集成到服务器渲染的应用程序中，可能会很棘手。你"),e("em",[this._v("可能")]),this._v("要通过模拟(mock)一些全局变量来使其正常运行（如可以通过 jsdom 来 mock 浏览器的 dom 对象，进行 html 解析），但这只是 hack 的做法，并且可能会干扰到其他 library 的环境检测代码。")])}],!1,null,null,null);o.options.__file="universal.md";e.default=o.exports}}]);